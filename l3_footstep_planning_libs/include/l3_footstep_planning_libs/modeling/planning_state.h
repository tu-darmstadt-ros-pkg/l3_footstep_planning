//=================================================================================================
// Copyright (c) 2022, Alexander Stumpf, TU Darmstadt
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Simulation, Systems Optimization and Robotics
//       group, TU Darmstadt nor the names of its contributors may be used to
//       endorse or promote products derived from this software without
//       specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//=================================================================================================

#ifndef FOOTSTEP_PLANNER_PLANNINGSTATE_H__
#define FOOTSTEP_PLANNER_PLANNINGSTATE_H__

#include <l3_libs/types/step.h>

#include <l3_footstep_planning_libs/math.h>
#include <l3_footstep_planning_libs/modeling/state_id.h>

namespace l3_footstep_planning
{
using namespace l3;

class PlanningState
{
public:
  // typedefs
  typedef l3::SharedPtr<PlanningState> Ptr;
  typedef l3::SharedPtr<const PlanningState> ConstPtr;

  /**
   * @brief Creates PlanningState. A planning state must only have a predecessor or
   * a successor (never both)!
   * @param state Current state (state after executing the step)
   * @param pred Predecessor state
   * @param succ Successor state
   * @param steps Changes transferring the current state from/into predecessor/successor state.
   *        If an empty map is given, it will be automatically generated by the given states.
   */
  PlanningState(StateHashed::ConstPtr state, StateHashed::ConstPtr pred = StateHashed::ConstPtr(), StateHashed::ConstPtr succ = StateHashed::ConstPtr(),
                Step::ConstPtr step = Step::ConstPtr());

  inline void addMovedFoot(FootStepData::Ptr foot_step_data) { step_->footStep().updateMovingLink(foot_step_data->origin->idx, foot_step_data); }
  inline void addSupportFoot(Foothold::ConstPtr foothold) { step_->footStep().updateNonMovingLink(foothold->idx, foothold); }

  inline void addMovedFloatingBase(BaseStepData::Ptr base_step_data) { step_->baseStep().updateMovingLink(base_step_data->origin->idx, base_step_data); }
  inline void addRestingFloatingBase(FloatingBase::ConstPtr floating_base) { step_->baseStep().updateNonMovingLink(floating_base->idx, floating_base); }

  inline void clearStep() { step_->clear(); }

  inline Step::Ptr getStep() { return step_; }
  inline Step::ConstPtr getStep() const { return step_; }

  inline FootIndexArray getMovedFootIndeces() const { return step_->footStep().getMovingLinkIndeces(); }
  inline FootIndexArray getSupportFootIndeces() const { return step_->footStep().getNonMovingLinkIndeces(); }

  inline BaseIndexArray getMovedFloatingBaseIndeces() const { return step_->baseStep().getMovingLinkIndeces(); }
  inline BaseIndexArray getRestingFloatingBaseIndeces() const { return step_->baseStep().getNonMovingLinkIndeces(); }

  inline StateHashed::ConstPtr getState() const { return state_; }
  inline StateHashed::ConstPtr getPredState() const { return pred_; }
  inline StateHashed::ConstPtr getSuccState() const { return succ_; }

  /**
   * @brief Returns robot center associated with this state
   * @return current robot center
   */
  inline const Pose& getFeetCenter() const { return state_->getFeetCenter(); }

  /**
   * @brief Returns given adjacent state which is either the predecessor or successor state.
   * @return Adjacent state
   */
  inline StateHashed::ConstPtr getAdjacentState() const { return adj_; }

  /**
   * @brief Returns all changed footholds which can either be based on step information
   * stored in the planning state.
   * @return List of changed footholds taken from current state
   */
  FootholdHashedConstPtrArray getChangedFootholds() const;

  /**
   * @brief Returns all unchanged footholds which can either be based on step information
   * stored in the planning state.
   * @return List of changed footholds taken from current state
   */
  FootholdHashedConstPtrArray getUnchangedFootholds() const;

  /**
   * @brief Returns all changed floating bases which can either be based on step information
   * stored in the planning state.
   * @return List of changed floating bases taken from current state
   */
  FloatingBaseHashedConstPtrArray getChangedFloatingBases() const;

  /**
   * @brief Returns all unchanged floating bases which can either be based on step information
   * stored in the planning state.
   * @return List of changed floating bases taken from current state
   */
  FloatingBaseHashedConstPtrArray getUnchangedFloatingBases() const;

  /**
   * @brief States are getting cached even they are invalid.
   * This flag indentifies such states.
   */
  void setValid(bool valid) { valid_ = valid; }
  inline bool isValid() const { return valid_; }

  VariantDataSet data;  // may contain robot specific data (Note: This data will not be serialized!)

private:
  // pointer to original state
  StateHashed::ConstPtr state_;
  StateHashed::ConstPtr pred_;
  StateHashed::ConstPtr succ_;
  StateHashed::ConstPtr adj_;

  Step::Ptr step_; // Steps transferring the current state into predecessor/successor state.

  bool valid_; // planning states are getting cached, although they may not be valid
};

class PlanningStateID
{
public:
  PlanningStateID(StateHashed::ConstPtr state, StateHashed::ConstPtr pred, StateHashed::ConstPtr succ, Step::ConstPtr step);
  PlanningStateID(StateHashed::ConstPtr state, StateHashed::ConstPtr pred, StateHashed::ConstPtr succ, const FootIndexSet& moved_foot_idx, const BaseIndexSet& moved_bases_idx);
  PlanningStateID(const PlanningState& state);

  inline bool operator==(const PlanningStateID& other) const
  {
    return hash_ == other.hash_ && state_id_ == other.state_id_ && pred_id_ == other.pred_id_ && foot_idx_ == other.foot_idx_ && base_idx_ == other.base_idx_;
  }

  inline const Hash& getHashValue() const { return hash_; }

private:
  StateID state_id_;
  StateID pred_id_;
  StateID succ_id_;
  FootIndexSet foot_idx_;
  BaseIndexSet base_idx_;

  Hash hash_;
};

typedef Hashed<PlanningState, PlanningStateID> PlanningStateHashed;
typedef Hasher<PlanningStateID> PlanningStateHasher;  // Hashing operator

L3_STATIC_ASSERT_MOVEABLE(PlanningState)
}  // namespace l3_footstep_planning
#endif
